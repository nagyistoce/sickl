# Simple Compute Kernel Library #

SiCKL is a library for writing kernel programs in simple, native C++ which dynamically generate programs which can be executed on the GPU.  Currently, only an OpenGL 3.3 backend is currently implemented (using fragment shaders and render to texture).  However, SiCKL is written in such a way that the program structure generated by the C++ frontend can be relatively easily mapped to any other backend.

SiCKL abstracts away the boring initialization code, and will generate compile errors if you attempt to create a malformed compute kernel.  It should be very difficult to make it to the GLSL code generation phase using an invalid program.

An example '[Mandelbrot](http://code.google.com/p/sickl/source/browse/trunk/source/SiCKL/Mandelbrot/Main.cpp)' program is provided that illustrates all the currently implemented features.

SiCKL makes use of the freeglut and glew libraries and the included Mandelbrot tutorial program makes use of the EasyBMP library.

## Tutorial ##

Writing kernel programs with SiCKL is relatively straight forward.  A kernel program is run many times in parallel over a 2 dimensional buffer (where the results are stored).  A SiCKL kernel has the following structure:

```
class MyKernel : public SiCKL::Source
{
	BEGIN_SOURCE
		BEGIN_CONST_DATA
			// list of input data to the kernel
			// can be primitives, vectors, 1D buffers of primitives, or 2D buffers of primitives
		END_CONST_DATA
		
		BEGIN_OUT_DATA
			// list of output data from the kernel
			// can be any primitive or vector type
		END_OUT_DATA
		
		BEGIN_MAIN
			// your program goes here
		END_MAIN
	END_SOURCE
};
```

SiCKL programs use their own primitive types (Bool, Int, UInt, Float, Int2, UInt2, Float2, Int3, UInt3, Float3, Int4, UInt4, and Float4).  In addition to these primitive types, SiCKL programs can read from 1 dimensional and 2 dimensional buffer types (Buffer1D`<T>` and Buffer2D`<T>`) which take a primitive type as a template argument.

SiCKL programs also make use of their own control flow structures (If, ElseIf, EndIf, While, EndWhile, ForInRange, EndFor).  There are also several built in functions available.

Each of these types and control statements actually come together and generate the kernel program structure when they are executed, rather then executing the program they appear to encode.  Because of this structure, regular C++ can be used as a sort of pre-processor for SiCKL source.  When SiCKL source is not evaluated, it does not become part of the final kernel program!


---


Let's look at a simple program for generating the Mandelbrot fractal using the escape time algorithm (http://en.wikipedia.org/wiki/Mandelbrot_set#Escape_time_algorithm).  This one will be a bit simpler than the one that lives in the provided Mandelbrot program.

```
class SimpleMandelbrot : public SiCKL::Source
{
	BEGIN_SOURCE
		BEGIN_CONST_DATA
			// coordinate of the top-left hand side of the image
			CONST_DATA(Float2, min)
			// coordinate of the bottom-right hand side of the image
			CONST_DATA(Float2, max)
		END_CONST_DATA
		
		BEGIN_OUT_DATA
			// number of iterations required to escape
			OUT_DATA(UInt, iteration)
		END_OUT_DATA
		
		BEGIN_MAIN
			// figure out the position in the image we're calculating
			Float pos0 = NormalizedIndex() * (max - min) + min;
			
			// references work just fine, we're in C++!
			Float& x0 = pos0.X;
			Float& y0 = pos0.Y;
			
			Float x = 0.0f;
			Float y = 0.0f;
			
			iteration = 0;
			UInt max_iteration = 1000;
			
			While(x*x + y*y < 2*2 && iteration < max_iteration)
				Float xtemp = x*x - y*y + x0;
				y = y0 + x * y * 2.0f;
				
				x = xtemp;
				
				iteration += 1;
			EndWhile
			
		END_MAIN
	END_SOURCE
};
```


We've defined our program.  To run it, we just  need to do a little bit of work:

```
// create the opengl context and setup everything we need to go
OpenGLRuntime::Initialize();
// create an instance of the OpenGL SiCKL compiler which we will use to generate our kernel program
OpenGLCompliler compiler;

// create an instance of our kernel source code
SimpleMandlebrot mandelbrot_source;

// parse the source for our compiler
mandelbrot_source.Parse();

// let's define what size our render target will be
const uint32_t width = 1400;
const uint32_t height = 800;

// create our program!
OpenGLProgram* program = compiler.Build(mandelbrot_source);
// and init it
program->Initialize(width, height);

// get the location handles for each of input and outputs
// this isn't necessary, locations are defined by the order in which they appear
// but for verbosity we'll pretend we don't know where they live
const input_t min_location = program->GetInputHandle("min"); // will be 0
const input_t max_location = program->GetInputHandle("max"); // will be 1
const output_t iteration_location = program->GetOutputHandle("iteration"); // will be 0

// now set the inputs and outputs on the program
program->SetInput(min_location, -2.5f, -1.0f);
program->SetInput(max_location, 1.0f, 1.0f);

// create a buffer to store our Mandelbrot fractal we're going to generate
// datatype is an unsigned int, and we aren't going to be initializing it with any data 
OpenGLBuffer2D result(width, height, ReturnType::UInt, nullptr);

program->SetOutput(iteration_location, result);

// finally, let's run this program!
program->Run();

// presumably, we want this fractal for something, so let's download it from the GPU
uint32_t* fractal = nullptr;
// allocates a width * height size buffer of uint32_t and sets fractal to point to it
program->GetOutput(iteration_location, fractal);


// do something with the fractal
SaveFractalToDisk(width, height, fractal);
```

If we wanted to make an animation, we could repeatedly update the program inputs (via SetInput), run the program, and save off the resulting image.